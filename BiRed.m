function [ A_out, t_out, r_out ] = BiRed( A, t, r )

  % input verification. A needs to be square per section 11.2.3
  [row, col] = size(A);
  if (row ~= col)
    disp("BiRed ERROR: Input matrix must be square");
    A_out = A;
    t_out = t;
    r_out = r;
    return;
  elseif ((row ~= max(size(t))) || (row ~= max(size(r))))
    disp("BiRed ERROR: Input dimensions don't match");
    A_out = A;
    t_out = t;
    r_out = r;
    return;
  end

  [ ATL, ATR, ...
    ABL, ABR ] = FLA_Part_2x2( A, ...
                               0, 0, 'FLA_TL' );

  [ tT, ...
    tB ] = FLA_Part_2x1( t, ...
                         0, 'FLA_TOP' );

  [ rT, ...
    rB ] = FLA_Part_2x1( r, ...
                         0, 'FLA_TOP' );

  while ( size( ATL, 1 ) < size( A, 1 ) )

    [ A00,  a01,     A02,  ...
      a10t, alpha11, a12t, ...
      A20,  a21,     A22 ] = FLA_Repart_2x2_to_3x3( ATL, ATR, ...
                                                    ABL, ABR, ...
                                                    1, 1, 'FLA_BR' );

    [ t0, ...
      tau1, ...
      t2 ] = FLA_Repart_2x1_to_3x1( tT, ...
                                    tB, ...
                                    1, 'FLA_BOTTOM' );

    [ r0, ...
      rho, ...
      r2 ] = FLA_Repart_2x1_to_3x1( rT, ...
                                    rB, ...
                                    1, 'FLA_BOTTOM' );
                                
    %------------------------------------------------------------%

    % special case: need to define a21 as the last scalar in the final loop
    % where we are only doing col Householder. Allows correct computation
    % of final tau1 value due to implementation of Housev1. The last
    % householder vecotr is empty per Piazza @1161
    if (size( ATL, 1 ) == size( A, 1 ) - 1)
        % employ Householder transformation for col
        x = [0; ...
             alpha11];
        [ucol, ...
         tau1] = Housev1(x);
        [ tT, ...
          tB ] = FLA_Cont_with_3x1_to_2x1( t0, ...
                                           tau1, ...
                                           t2, ...
                                          'FLA_TOP' );
        break;
    else
        % employ Householder transformation for col
        x = [alpha11; ...
             a21];
    end
    
    [ucol, ...
     tau1] = Housev1(x);
    alpha11 = ucol(1);
    u21 = ucol(2:end);
    a21 = u21; % implicitly, a21 in updated matrix = zero vector

    % update a12^T and A22
    uForHCol = [1; ...
                u21];
    HforCol = eye(max(size(uForHCol))) - (1/tau1) * (uForHCol * uForHCol'); % optimize by having fixed dimension
    temp = HforCol * [a12t; ...
                A22];
    [temp_rows, temp_cols] = size(temp);
    a12t = temp(1,:);
    A22 = temp(2:temp_rows, 1:temp_cols);
    
    % now, a21 has been overwritten by u21

    % special case: last loop only does col -- Piazza @1134
    if (size( ATL, 1 ) == size( A, 1 ) - 1)
        [ tT, ...
          tB ] = FLA_Cont_with_3x1_to_2x1( t0, ...
                                           tau1, ...
                                           t2, ...
                                           'FLA_TOP' );
       break;
    end
   
    % employ Householder transformation for row
    [u12, rho] = Housev1(a12t');
    a12t = u12';

    % update A22
    uForHRow = u12;
    uForHRow(1) = 1;
    HforRow = eye(max(size(uForHRow))) - (1/rho) * (uForHRow * uForHRow');
    A22 = A22 * HforRow;

    % update A, t, and r for next iteration
    %------------------------------------------------------------%

    [ ATL, ATR, ...
      ABL, ABR ] = FLA_Cont_with_3x3_to_2x2( A00,  a01,     A02,  ...
                                             a10t, alpha11, a12t, ...
                                             A20,  a21,     A22, ...
                                             'FLA_TL' );

    [ tT, ...
      tB ] = FLA_Cont_with_3x1_to_2x1( t0, ...
                                       tau1, ...
                                       t2, ...
                                       'FLA_TOP' );

    [ rT, ...
      rB ] = FLA_Cont_with_3x1_to_2x1( r0, ...
                                       rho, ...
                                       r2, ...
                                       'FLA_TOP' );
                                   
  end

  A_out = [ ATL, ATR
            ABL, ABR ];

  t_out = [ tT
            tB ];
        
  r_out = [ rT
            rB ];

return
